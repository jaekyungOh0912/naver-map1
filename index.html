<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>지도 테스트</title>
  <script src="https://oapi.map.naver.com/openapi/v3/maps.js?ncpKeyId=n08un8adzv&submodules=geocoder"></script>
  <script src="MarkerClustering.js"></script>
  <script src="markerData.js"></script>
  <script src="sigunguData.js"></script>
  <script src="dongData.js"></script>
  <style>
    body { margin: 0; padding: 0; }
    button { outline: none; cursor: pointer; }

    .searchBox {
      width: 100%; height: 70px; background-color: #E5EDF8;
      position: fixed; top: 0; left: 0;
      z-index: 999;
    }
    .searchBox .searchInputBox {
      width: calc(100% - 20px); max-width: 340px; height: 50px;
      background-color: #FFFFFF;
      margin: 8px auto 0;
      display: flex; align-content: space-between; justify-items: center;
      overflow: hidden;
    }
    .searchBox .searchInputBox input {
      width: calc(100% - 55px); height: 50px;
      padding: 0 5px; border: none; box-sizing: border-box;
    }
    .searchBox .searchInputBox button {
      width: 50px; height: 50px;
      margin: 0; padding: 0; border: none;
      background-color: transparent;
    }

    .searchBox ul {
      width: calc(100% - 20px); max-width: 340px; max-height: 150px;
      list-style: none;
      padding: 0;
      margin: 5px 0 0 0;
      overflow-y: auto;
      background: #fff;
      border: 1px solid #ccc;
      position: fixed;
      top: 55px;
      left: 50%;
      transform: translateX(-50%);
    }
    .searchBox li {
      padding: 10px 8px;
      cursor: pointer;
      font-size: 14px;
      border-bottom: 1px solid #DDD;
    }
    .searchBox li:hover {
      background: #f0f0f0;
    }

    #map { width:100dvw; height:100dvh; }

    .filterBox {
      position: fixed; top: 10dvh; right: 25px;
    }
    .filterBox button {
      width: 60px; height: 60px; display: block;
      margin-top: 10px; font-size: 12px;
    }
    .filterBox button:nth-child(1) { margin-top: 0; }
    .filterBox button.active { background-color: red; color: white; }

    .controlBox {
      position: fixed; top: 10dvh; left: 25px;
    }
    .controlBox button {
      width: 60px; height: 60px; display: block;
      margin-top: 10px; font-size: 12px;
    }
    .controlBox button:nth-child(1) { margin-top: 0; }

    .addressBox {
      position: fixed;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255,255,255,0.9);
      padding: 8px 14px;
      border-radius: 6px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      font-size: 14px;
      color: #333;
      z-index: 998;
    }

    #mapComponent.hide .searchBox {
      display: none;
    }
    #mapComponent.hide .filterBox {
      display: none;
    }
    #mapComponent.hide .controlBox {
      display: none;
    }
    #mapComponent.hide .addressBox {
      display: none;
    }
  </style>
</head>
<body>
<div id="mapComponent">
  <div class="searchBox">
    <div class="searchInputBox">
      <input type="text" id="searchInput" placeholder="주소를 입력하세요" />
      <button onclick="searchAddress()">
        <img src="image/search.png" alt="검색">
      </button>
    </div>
    <ul id="searchResults"></ul>
  </div>
  <div id="map"></div>

  <div class="addressBox" id="addressBox">주소를 불러오는 중...</div>

  <div class="filterBox">
    <button class="active" onclick="handleFilterChange(0)">전체</button>
    <button onclick="handleFilterChange(1)">아파트</button>
    <button onclick="handleFilterChange(2)">오피스텔</button>
    <button onclick="handleFilterChange(3)">연립,다세대</button>
  </div>

  <div class="controlBox">
    <button onclick="goMyLocation()">📍</button>
    <button onclick="zoomIn()">＋</button>
    <button onclick="zoomOut()">－</button>
  </div>
</div>

<script>
  let markerDataList = markerData;

  const map = new naver.maps.Map('map', {
    center: new naver.maps.LatLng(35.144, 129.060),
    zoom: 16,
    minZoom: 7,
    maxZoom: 19
  });

  const addressBox = document.getElementById("addressBox");

  // ✅ 도로명 주소 변환 함수
  function updateAddress(lat, lng) {
    naver.maps.Service.reverseGeocode({
      coords: new naver.maps.LatLng(lat, lng),
      orders: [
        naver.maps.Service.OrderType.ROAD_ADDR,
        naver.maps.Service.OrderType.ADDR
      ].join(',')
    }, function(status, response) {
      if (status !== naver.maps.Service.Status.OK) {
        addressBox.innerText = "주소를 가져올 수 없습니다.";
        return;
      }
      const result = response.v2.address;
      if (result.roadAddress) {
        addressBox.innerText = "📍 " + result.roadAddress;
      } else {
        addressBox.innerText = "📍 " + (result.jibunAddress || "주소 없음");
      }
    });
  }

  // ✅ 주소 검색 기능 https 환경이 아니라서 테스트 불가
  /* async function searchAddress() {
    const query = document.getElementById("searchInput").value.trim();
    if (!query) return alert("주소를 입력하세요.");

    const clientId = "n08un8adzv";       // ✅ 발급받은 값
    const clientSecret = "898pT7rHlouyjrsqhdMr9I2q5ec9bDE5JvsdK2eF"; // ✅ 발급받은 값

    // ✅ Geocoding API (주소 → 좌표)
    const url = `https://naveropenapi.apigw.ntruss.com/map-geocode/v2/geocode?query=${encodeURIComponent(query)}`;

    try {
      const res = await fetch(url, {
        headers: {
          "X-NCP-APIGW-API-KEY-ID": clientId,
          "X-NCP-APIGW-API-KEY": clientSecret
        }
      });

      if (!res.ok) {
        alert("주소 검색 요청 실패");
        return;
      }

      const data = await res.json();
      const resultList = data.addresses;
      const resultBox = document.getElementById("searchResults");
      resultBox.innerHTML = "";

      if (!resultList.length) {
        resultBox.innerHTML = "<li>검색 결과가 없습니다.</li>";
        return;
      }

      resultList.forEach((addr) => {
        const li = document.createElement("li");
        li.style.cursor = "pointer";
        li.style.padding = "4px 6px";
        li.style.borderBottom = "1px solid #ddd";
        li.innerText = addr.roadAddress || addr.jibunAddress || "(주소 없음)";

        li.addEventListener("click", () => {
          const y = parseFloat(addr.y);
          const x = parseFloat(addr.x);
          const newCenter = new naver.maps.LatLng(y, x);

          // ✅ 지도 중심 이동 및 마커 생성
          map.setCenter(newCenter);
          map.setZoom(16);
          new naver.maps.Marker({ position: newCenter, map: map });

          // ✅ 기존 updateAddress 사용 가능
          updateAddress(y, x);

          resultBox.innerHTML = "";
        });

        resultBox.appendChild(li);
      });
    } catch (e) {
      console.error(e);
      alert("오류가 발생했습니다.");
    }
  } */

  function searchAddress() {
    const query = document.getElementById("searchInput").value.trim();
    if (!query) return alert("주소를 입력하세요.");

    const cleanQuery = query.replace(/[^가-힣0-9a-zA-Z\s]/g, "").trim();

    naver.maps.Service.geocode({ query: cleanQuery }, function (status, response) {
      if (status !== naver.maps.Service.Status.OK) {
        alert("검색 결과가 없습니다.");
        return;
      }

      const resultList = response.v2.addresses;
      const resultBox = document.getElementById("searchResults");
      resultBox.innerHTML = "";

      if (!resultList.length) {
        resultBox.innerHTML = "<li style='padding:4px 6px;'>검색 결과가 없습니다.</li>";
        return;
      }

      resultList.forEach((addr) => {
        const fullAddr = addr.roadAddress || addr.jibunAddress || "(주소 없음)";

        if (!fullAddr.includes(query) && !fullAddr.replace(/\s/g, "").includes(query.replace(/\s/g, ""))) {
          return;
        }

        const li = document.createElement("li");
        li.innerText = fullAddr;

        li.addEventListener("click", () => {
          const x = parseFloat(addr.x);
          const y = parseFloat(addr.y);
          const newCenter = new naver.maps.LatLng(y, x);

          map.setCenter(newCenter);
          map.setZoom(16);

          new naver.maps.Marker({
            position: newCenter,
            map: map
          });

          updateAddress(y, x);

          // ✅ 검색 후 리스트와 입력값 초기화
          resultBox.innerHTML = "";
          document.getElementById("searchInput").value = "";  // 🔥 추가됨
        });

        resultBox.appendChild(li);
      });
    });
  }


  // ✅ 내 위치 마커를 전역 변수로 선언
  let myLocationMarker = null;

  // ✅ 내 위치 이동 (첫 로딩 + 버튼 공용)
  function goMyLocation() {
    if (!navigator.geolocation) return;

    navigator.geolocation.getCurrentPosition(
      (pos) => {
        const lat = pos.coords.latitude;
        const lng = pos.coords.longitude;
        const loc = new naver.maps.LatLng(lat, lng);

        if (!myLocationMarker) {
          // 최초 한 번만 마커 생성
          myLocationMarker = new naver.maps.Marker({
            position: loc,
            map: map,
            icon: {
              url: "https://maps.gstatic.com/mapfiles/ms2/micons/red-dot.png",
              size: new naver.maps.Size(32, 32),
              scaledSize: new naver.maps.Size(32, 32),
            },
          });
        } else {
          // 이후에는 위치만 갱신
          myLocationMarker.setPosition(loc);
        }

        map.setCenter(loc);
        map.setZoom(16);
        updateAddress(lat, lng);
      },
      () => {
        addressBox.innerText = "위치 정보를 가져올 수 없습니다.";
      }
    );
  }

  window.addEventListener("load", () => {
    goMyLocation();
  });

  function zoomIn() { map.setZoom(map.getZoom() + 1); }
  function zoomOut() { map.setZoom(map.getZoom() - 1); }

  // ✅ 이하 기존 마커/클러스터/폴리곤 코드는 그대로 사용
  const infoWindow = new naver.maps.InfoWindow({
    borderWidth: 0,
    disableAnchor: true,
    backgroundColor: "transparent",
    pixelOffset: new naver.maps.Point(0, -10)
  });

  const markers = [];

  function setMarkers(lat, lng, type, name, price, count) {
    // ✅ 매물개수 원 생성
    const countHTML = (count && count > 0) ? `
      <div style="
        position:absolute;
        top:-5px;
        right:-5px;
        width:18px;
        height:18px;
        background:red;
        color:white;
        font-size:11px;
        font-weight:bold;
        text-align:center;
        line-height:18px;
        border-radius:50%;
        box-shadow:0 1px 3px rgba(0,0,0,0.3);
      ">${count}</div>
    ` : "";

    // ✅ 마커 기본 아이콘
    const markerHTML = `
      <div style="position:relative; width:30px; height:30px;">
        <img src="./image/type${type}.png" alt="마커" style="width:30px; height:30px; display:block;" />
        ${countHTML}
      </div>
    `;


    const marker = new naver.maps.Marker({
      position: new naver.maps.LatLng(lat, lng),
      icon: {
        content: markerHTML,
        size: new naver.maps.Size(30, 30),
        scaledSize: new naver.maps.Size(30, 30)
      }
    });

    naver.maps.Event.addListener(marker, "click", () => {
      const contentHTML = `
        <div style="
          background:#fff;
          border:1px solid #ccc;
          border-radius:8px;
          padding:10px;
          width:150px;
          box-shadow:0 2px 6px rgba(0,0,0,0.2);
          font-family:sans-serif;
          font-size:13px;
        ">
          <div style="font-weight:bold;color:#333;margin-bottom:4px;">
            ${name}
          </div>
          <div style="color:#d9534f;font-weight:bold;">
            ${price.toLocaleString()}원
          </div>
          <button style="
            margin-top:6px;
            width:100%;
            background:#007bff;
            color:#fff;
            border:none;
            border-radius:4px;
            padding:4px;
            cursor:pointer;
          ">상세보기</button>
        </div>`;
      infoWindow.setContent(contentHTML);
      infoWindow.open(map, marker);
    });

    naver.maps.Event.addListener(map, "click", () => {
      infoWindow.close();
    });

    markers.push(marker);
  }

  markerDataList.forEach(v => {
    const name = v.name || "건물명 없음";
    const price = v.price || 0;
    setMarkers(v.lat, v.lng, v.type, name, price, v.count);
  });

  function getBaseIcon(size) {
    return {
      content: `<div style="
      cursor:pointer;
      width:${size}px;
      height:${size}px;
      line-height:${size + 2}px;
      font-size:${Math.max(12, size / 3)}px;
      color:white;
      text-align:center;
      font-weight:bold;
      background:url(./image/baseIcon.png);
      background-size:contain;"></div>`,
      size: new naver.maps.Size(size, size),
      anchor: new naver.maps.Point(size / 2, size / 2)
    };
  }

  function updateClusterIconsByZoom() {
    const zoom = map.getZoom();
    const defaultZoom = 16 - zoom;
    // ✅ 줌 값이 작을수록 아이콘이 커지도록 설정
    let iconSize;
    if (defaultZoom > 0) iconSize = 50 + (15 * defaultZoom);
    else iconSize = 50;

    clusterIcons = [1, 2, 3, 4, 5].map(() => getBaseIcon(iconSize));

    if (cluster) {
      // 클러스터링 다시 적용
      updateMarkersByPolygon();
    }
  }

  let clusterIcons = [1, 2, 3, 4, 5].map(() => getBaseIcon(40));

  let cluster = null;
  let activePolygon = null;
  let dataList = dongGeoJson.features;

  function isPointInsidePolygon(point, paths) {
    const x = point.lng(), y = point.lat();
    let inside = false;
    paths.forEach(path => {
      for (let i = 0, j = path.length - 1; i < path.length; j = i++) {
        const xi = path[i].lng(), yi = path[i].lat();
        const xj = path[j].lng(), yj = path[j].lat();
        const intersect = ((yi > y) !== (yj > y)) &&
          (x < (xj - xi) * (y - yi) / ((yj - yi) || 1e-10) + xi);
        if (intersect) inside = !inside;
      }
    });
    return inside;
  }

  function createPolygon(feature) {
    const paths = [];
    if (feature.geometry.type === "Polygon") {
      feature.geometry.coordinates.forEach(ring =>
        paths.push(ring.map(([lng, lat]) => new naver.maps.LatLng(lat, lng))));
    } else {
      feature.geometry.coordinates.forEach(poly =>
        poly.forEach(ring =>
          paths.push(ring.map(([lng, lat]) => new naver.maps.LatLng(lat, lng)))));
    }
    return new naver.maps.Polygon({
      paths,
      fillColor: '#FE7E33',
      fillOpacity: 0.1,
      strokeColor: '#FE7E33',
      strokeOpacity: 1,
      strokeWeight: 2,
      clickable: false
    });
  }

  function updateMarkersByPolygon() {
    if (!activePolygon) {
      if (cluster) cluster.setMap(null);
      return;
    }
    const paths = activePolygon.getPaths().getArray().map(path => path.getArray());
    const visibleMarkers = markers.filter(m => isPointInsidePolygon(m.getPosition(), paths));

    if (cluster) cluster.setMap(null);
    cluster = new MarkerClustering({
      map,
      markers: visibleMarkers,
      disableClickZoom: false,
      gridSize: 300,
      minClusterSize: 1,
      maxZoom: 18,
      icons: clusterIcons,
      indexGenerator: [10, 100, 200, 500, 1000],
      stylingFunction: (clusterMarker, count) => {
        clusterMarker.getElement().querySelector('div:first-child').innerText = count;
      }
    });
  }

  function renderRegionAtCenter(center) {
    if (activePolygon) activePolygon.setMap(null);
    activePolygon = null;
    for (const feature of dataList) {
      const polygon = createPolygon(feature);
      const paths = polygon.getPaths().getArray().map(path => path.getArray());
      if (isPointInsidePolygon(center, paths)) {
        polygon.setMap(map);
        activePolygon = polygon;
        break;
      }
    }
    updateMarkersByPolygon();
  }

  function refreshMapData() {
    renderRegionAtCenter(map.getCenter());
  }

  naver.maps.Event.addListener(map, 'idle', refreshMapData);
  naver.maps.Event.addListener(map, 'zoom_changed', function (zoom) {
    if (zoom > 14) dataList = dongGeoJson.features;
    else if (zoom > 11) dataList = sigunguGeoJson.features;
    else dataList = [];

    updateClusterIconsByZoom(); // ✅ 줌 변경될 때 아이콘 크기 변경
  });

  refreshMapData();

  function handleFilterChange(type) {
    const filterBtn = document.querySelectorAll(".filterBox button");
    filterBtn.forEach((element, index) => {
      element.classList.toggle("active", type === index);
    });

    markerDataList = (type === 0) ? markerData : markerData.filter(v => v.type === type);

    markers.length = 0;
    markerDataList.forEach(v => {
      const name = v.name || "건물명 없음";
      const price = v.price || 0;
      setMarkers(v.lat, v.lng, v.type, name, price);
    });

    refreshMapData();
  }

  // ✅ 지도 클릭 이벤트 (마커가 아닌 지도 영역 클릭 시 발생)
  naver.maps.Event.addListener(map, "click", () => {
    const mapComponent = document.getElementById("mapComponent");

    if (!mapComponent) return; // 요소가 없으면 종료

    mapComponent.classList.toggle("hide"); // ✅ toggle로 간결하게 처리
  });
</script>
</body>
</html>
