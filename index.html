<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>지도 테스트</title>
  <!-- 네이버 지도, 클러스터링, 데이터 -->
  <script src="https://oapi.map.naver.com/openapi/v3/maps.js?ncpKeyId=n08un8adzv&submodules=geocoder"></script>
  <script src="./MarkerClustering.js"></script>
  <script src="./markerData.js"></script>
  <script src="./sigunguData.js"></script>
  <style>
    /* 기본 레이아웃 및 UI 스타일 */
    body { margin: 0; padding: 0; }
    button { outline: none; cursor: pointer; }
    p { margin: 0; }
    .searchBox { width:100%;height:70px;background:#E5EDF8;position:fixed;top:0;left:0;z-index:999; }
    .searchBox .searchInputBox { width:calc(100% - 20px);max-width:340px;height:50px;background:#fff;margin:8px auto 0;display:flex;overflow:hidden; }
    .searchBox .searchInputBox input { width:calc(100% - 55px);height:50px;padding:0 5px;border:none;box-sizing:border-box; }
    .searchBox .searchInputBox button { width:50px;height:50px;border:none;background:transparent; }
    .searchBox ul { width:calc(100% - 20px);max-width:340px;max-height:150px;list-style:none;padding:0;margin:5px 0 0 0;overflow-y:auto;background:#fff;border:1px solid #ccc;position:fixed;top:55px;left:50%;transform:translateX(-50%);}
    .searchBox li { padding:10px 8px;cursor:pointer;font-size:14px;border-bottom:1px solid #DDD; }
    .searchBox li:hover { background:#f0f0f0; }
    #map { width:100dvw; height:100dvh; }
    .filterBox { position:fixed;top:75px;right:10px; }
    .filterBox button { width:50px;height:50px;display:block;margin-top:8px;font-size:12px; }
    .filterBox button:nth-child(1) { margin-top:0; }
    .filterBox button.active { background:red;color:white; }
    .controlBox { position:fixed;top:75px;left:10px; }
    .controlBox button { width:50px;height:50px;display:block;margin-top:8px;font-size:12px; }
    .controlBox button:nth-child(1) { margin-top:0; }
    .addressBox { position:fixed;top:80px;left:50%;transform:translateX(-50%);background:rgba(255,255,255,0.9);padding:8px 14px;border-radius:6px;box-shadow:0 2px 4px rgba(0,0,0,0.2);font-size:14px;color:#333;z-index:998;}
    #mapComponent.hide .searchBox,
    #mapComponent.hide .filterBox,
    #mapComponent.hide .controlBox,
    #mapComponent.hide .addressBox { display:none; }

    /* 마커 */
    .marker { width: 30px; height: 30px; position: relative; }
    .marker img { width: 30px; height: 30px; }
    .marker .count { width: 18px; height: 18px; position: absolute; top: -5px; right: -10px; background-color: red; color: white; font-size: 11px; line-height: 18px; text-align: center; border-radius: 50%; }
    .marker .count.deActive { background-color: gray;}
    .marker .textBox { width: 80px; height: 40px; position: absolute; padding: 0 3px; bottom: -40px; right: -25px; background-color: white; font-size: 13px; border-radius: 6px;}

    /* infoBox */
    .infoBox { position: fixed; bottom: -55dvh; left: 0; width: 100dvw; height: 55dvh; background-color: #FFF; z-index: 100; transition: bottom 0.3s ease-in-out;}
    .infoBox.show {bottom: 0;}
    .infoBox .infoHead p {padding: 5px; font-weight: 600;}
    .infoBox .infoHead ul {
      display: flex;
      align-items: center;
      justify-content: center;  /* 가운데 정렬 */
      margin: 0;
      padding: 0;
      border-top: 1px solid #333;
      border-bottom: 1px solid #333;
    }

    .infoBox .infoHead ul li {
      list-style: none;
      width: 20%;
      text-align: center;
      padding: 5px 0;
      color: #666;
      position: relative;
      cursor: pointer;
      font-size: 14px;
    }

    .infoBox .infoHead ul li.active {
      color: #008000; font-weight: 600;
    }

    .infoBox .infoHead ul li:not(:last-child)::after {
      content: "";
      position: absolute;
      right: 0;
      top: 50%;
      transform: translateY(-50%);
      height: 10px;
      border-right: 1px solid #333;
    }

    .infoBox .infoBody {
      height: calc(100% - 65px);
      overflow-y: auto;
      overflow-x: hidden;
    }

    .infoBox .infoBody .infoContentBox {
      padding: 8px 0;
      margin: 0 5px;
      width: calc(100% - 10px);
      box-sizing: border-box;
    }
    .infoBox .infoBody .infoContentBox:not(:last-child) {
      border-bottom: 1px solid #333;
    }
    .infoBox .infoBody .infoContentBox p {
      font-size: 14px;
      color: #666666;
    }
    .infoBox .infoBody .infoContentBox p:nth-child(1) {
      font-weight: 700;
      color: #333;
      font-size: 16px;
    }
  </style>
</head>
<body>
<div id="mapComponent">
  <!-- 주소 검색 박스 -->
  <div class="searchBox">
    <div class="searchInputBox">
      <input type="text" id="searchInput" placeholder="주소를 입력하세요" />
      <button onclick="searchAddress()"><img src="image/search.png" alt="검색"></button>
    </div>
    <ul id="searchResults"></ul>
  </div>

  <!-- 지도 영역 -->
  <div id="map"></div>

  <!-- 현재 주소 표시 -->
  <div class="addressBox" id="addressBox">주소를 불러오는 중...</div>

  <!-- 필터 버튼 -->
  <div class="filterBox">
    <button class="active" onclick="handleFilterChange(0)">전체</button>
    <button onclick="handleFilterChange(1)">아파트</button>
    <button onclick="handleFilterChange(2)">오피스텔</button>
    <button onclick="handleFilterChange(3)">연립,다세대</button>
  </div>

  <!-- 컨트롤 버튼 -->
  <div class="controlBox">
    <button onclick="goMyLocation()">📍</button>
    <button onclick="zoomIn()">＋</button>
    <button onclick="zoomOut()">－</button>
  </div>

  <!-- 정보 레이어 영역 -->
  <div class="infoBox">
    <div class="infoHead">
      <p>총 <span class="count">7</span>개의 단지가 있습니다</p>
      <ul>
        <li class="active" onclick="handelSortFilter(event, 1)">인기순</li>
        <li onclick="handelSortFilter(event, 2)">가나다순</li>
        <li onclick="handelSortFilter(event, 3)">세대수순</li>
        <li onclick="handelSortFilter(event, 4)">최근입주순</li>
        <li onclick="handelSortFilter(event, 5)">매물수순</li>
      </ul>
    </div>
    <div class="infoBody">
      <div class="infoContentBox">
        <p>서면동일파크스위트3차</p>
        <p>매매 3억 4,500 ~ 7억 1,000</p>
        <p>아파트·727세대·총9동·2017.06.30.</p>
        <p>53.85㎡ ~ 144.84㎡</p>
      </div>
      <div class="infoContentBox">
        <p>서면동일파크스위트3차</p>
        <p>매매 3억 4,500 ~ 7억 1,000</p>
        <p>아파트·727세대·총9동·2017.06.30.</p>
        <p>53.85㎡ ~ 144.84㎡</p>
      </div>
      <div class="infoContentBox">
        <p>서면동일파크스위트3차</p>
        <p>매매 3억 4,500 ~ 7억 1,000</p>
        <p>아파트·727세대·총9동·2017.06.30.</p>
        <p>53.85㎡ ~ 144.84㎡</p>
      </div>
    </div>
  </div>
</div>

<script>
  /* -------------------------------
     ✅ 전역 변수 및 초기 설정
  --------------------------------*/
  let markerDataList = markerData;       // 기본 마커 데이터
  const map = new naver.maps.Map('map', { // 지도 초기화
    center: new naver.maps.LatLng(35.144, 129.060),
    zoom: 16, minZoom:7, maxZoom:19
  });
  const addressBox = document.getElementById("addressBox");

  const loadedEmdCodes = [];    // 이미 로드된 행정동 코드
  const polygonCache = {};      // 폴리곤 캐싱
  let cluster = null;           // 마커 클러스터
  let activePolygon = null;     // 현재 활성화된 폴리곤
  let dataList = [];            // 현재 지도에 표시할 데이터
  let currentEmdData = null;    // 현재 행정동 데이터
  const markers = [];           // 지도에 표시된 마커 목록

  /* -------------------------------
     ✅ 동적 스크립트 로딩 (행정동 데이터)
  --------------------------------*/
  function loadEmdScript(code, callback) {
    // 이미 불러온 데이터면 콜백만 실행
    if (window["emd_" + code]) {
      if (!loadedEmdCodes.includes(code)) loadedEmdCodes.push(code);
      callback && callback();
      return;
    }
    // 중복 요청 방지
    if (loadedEmdCodes.includes(code)) {
      callback && callback();
      return;
    }
    // 새로운 스크립트 로드
    const script = document.createElement("script");
    script.src = `./dongData/emd_${code}.js`;
    script.onload = () => {
      loadedEmdCodes.push(code);
      callback && callback();
    };
    document.body.appendChild(script);
  }

  /* -------------------------------
     ✅ 주소 변환 및 검색
  --------------------------------*/
  // 현재 중심 좌표의 주소 갱신
  function updateAddress(lat, lng) {
    naver.maps.Service.reverseGeocode({
      coords: new naver.maps.LatLng(lat, lng),
      orders: [naver.maps.Service.OrderType.ROAD_ADDR, naver.maps.Service.OrderType.ADDR].join(',')
    }, (status, response) => {
      if (status !== naver.maps.Service.Status.OK) {
        addressBox.innerText = "주소를 가져올 수 없습니다."; return;
      }
      const result = response.v2.address;
      addressBox.innerText = "📍 " + (result.roadAddress || result.jibunAddress || "주소 없음");
    });
  }

  // 주소 검색
  function searchAddress() {
    const query = document.getElementById("searchInput").value.trim();
    if (!query) return alert("주소를 입력하세요.");

    const cleanQuery = query.replace(/[^가-힣0-9a-zA-Z\s]/g, "").trim();
    naver.maps.Service.geocode({ query: cleanQuery }, (status, response) => {
      if (status !== naver.maps.Service.Status.OK) return alert("검색 결과가 없습니다.");

      const resultList = response.v2.addresses;
      const resultBox = document.getElementById("searchResults");
      resultBox.innerHTML = "";

      if (!resultList.length) {
        resultBox.innerHTML = "<li style='padding:4px 6px;'>검색 결과가 없습니다.</li>"; return;
      }

      resultList.forEach(addr => {
        const fullAddr = addr.roadAddress || addr.jibunAddress || "(주소 없음)";
        if (!fullAddr.includes(query) && !fullAddr.replace(/\s/g, "").includes(query.replace(/\s/g, ""))) return;

        // 검색 결과 클릭 시 지도 이동
        const li = document.createElement("li");
        li.innerText = fullAddr;
        li.addEventListener("click", () => {
          const x = parseFloat(addr.x), y = parseFloat(addr.y);
          const newCenter = new naver.maps.LatLng(y, x);
          map.setCenter(newCenter); map.setZoom(16);
          new naver.maps.Marker({ position: newCenter, map: map });
          updateAddress(y, x);
          resultBox.innerHTML = "";
          document.getElementById("searchInput").value = "";
        });
        resultBox.appendChild(li);
      });
    });
  }

  /* -------------------------------
     ✅ 마커 관련
  --------------------------------*/
  const infoWindow = new naver.maps.InfoWindow({
    borderWidth:0, disableAnchor:true, backgroundColor:"transparent",
    pixelOffset:new naver.maps.Point(0,-10)
  });

  // 마커 생성
  function setMarkers(lat,lng,type,name,price,count,active){
    const priceText = price / 100000000;

    const countHTML = (count && count>0)
      ? `<div class="count ${active ? '' : 'deActive'}">${count}</div>` : "";
    const textHTML = `<div class="textBox"><p>${name}</p><p>${active ? `${priceText.toFixed(2)}억원` : ""}</p></div>`
    const markerHTML = `<div class="marker"><img src="./image/type${type}.png""/>${countHTML}${textHTML}</div>`;

    const marker = new naver.maps.Marker({
      position: new naver.maps.LatLng(lat,lng),
      icon:{content:markerHTML,size:new naver.maps.Size(30,30),scaledSize:new naver.maps.Size(30,30)}
    });
    // 마커 클릭 시 InfoWindow 표시
    naver.maps.Event.addListener(marker,"click",()=>{
      const infoBox = document.querySelector(".infoBox");
      const sortedData = [...complexList].sort((a, b) => b.popularity - a.popularity);

      infoBox.querySelector(".count").innerText = sortedData.length;
      setInfoContent(sortedData);
      infoBox.classList.add("show");
    });

    naver.maps.Event.addListener(map,"click",()=>infoWindow.close());
    markers.push(marker);
  }

  function setInfoContent(sortedData) {
    const infoBody = document.querySelector(".infoBody");
    infoBody.innerHTML = "";

    sortedData.forEach(value => {
      const box = document.createElement("div");
      box.className = "infoContentBox";

      box.innerHTML = `
        <p>${value.name}</p>
        <p>${value.price}</p>
        <p>${value.info}</p>
        <p>${value.size}</p>
      `;

      infoBody.appendChild(box);
    });
  }

  function clearMarkers(){ markers.forEach(m=>m.setMap(null)); markers.length=0; }
  function renderMarkers(list){ clearMarkers(); list.forEach(v=>setMarkers(v.lat,v.lng,v.type,v.name||"건물명 없음",v.price||0,v.count,v.active)); }

  // infoBox 외부 클릭 시 .show 제거
  document.addEventListener("click", (e) => {
    const infoBox = document.querySelector(".infoBox");

    if (!infoBox) return;

    // infoBox 내부를 클릭한 경우 무시
    if (infoBox.contains(e.target)) return;

    // 마커를 클릭할 경우 무시
    if (e.target.closest(".marker")) return;

    // 그 외 영역 클릭 시 .show 제거
    infoBox.classList.remove("show");
  });

  // 정보 박스 순서 정렬(정렬기능은 아직 미정)
  const handelSortFilter = (e, type) => {
    const sortFilter = document.querySelectorAll(".infoHead li");
    sortFilter.forEach((element) => {
      element.classList.remove("active");
    });

    const sortedData = [...complexList];

    switch (type) {
      case 1: // 인기순
        sortedData.sort((a, b) => b.popularity - a.popularity);
        break;
      case 2: // 이름 가나다순 (localeCompare로 한글 지원)
        sortedData.sort((a, b) => a.name.localeCompare(b.name, 'ko'));
        break;
      case 3: // 세대수순
        sortedData.sort((a, b) => b.household_count - a.household_count);
        break;
      case 4: // 최근입주순
        sortedData.sort((a, b) => new Date(b.move_in_date) - new Date(a.move_in_date));
        break;
      case 5: // 매물수순
        sortedData.sort((a, b) => b.sale_count - a.sale_count);
        break;
      default:
        sortedData.sort((a, b) => b.popularity - a.popularity);
    }

    console.log(sortedData);
    setInfoContent(sortedData);
    e.target.classList.add("active");
  }

  /* -------------------------------
     ✅ 폴리곤 및 클러스터
  --------------------------------*/
  function createPolygon(feature){
    const key = feature.properties.EMD_CD || JSON.stringify(feature.geometry);
    if (polygonCache[key]) return polygonCache[key];

    const paths = [];
    if(feature.geometry.type==="Polygon"){
      feature.geometry.coordinates.forEach(ring=>paths.push(ring.map(([lng,lat])=>new naver.maps.LatLng(lat,lng))));
    } else {
      feature.geometry.coordinates.forEach(poly=>poly.forEach(ring=>paths.push(ring.map(([lng,lat])=>new naver.maps.LatLng(lat,lng)))));
    }

    const polygon = new naver.maps.Polygon({
      paths,
      fillColor:'#FE7E33',
      fillOpacity:0.1,
      strokeColor:'#FE7E33',
      strokeOpacity:1,
      strokeWeight:2,
      clickable:false
    });
    polygon.bounds = getPathsBounds(paths);
    polygonCache[key] = polygon;
    return polygon;
  }

  function getPathsBounds(paths){
    const bounds = new naver.maps.LatLngBounds();
    paths.forEach(path => path.forEach(p => bounds.extend(p)));
    return bounds;
  }

  function isPointInsidePolygon(point,paths){
    const x=point.lng(),y=point.lat(); let inside=false;
    paths.forEach(path=>{
      for(let i=0,j=path.length-1;i<path.length;j=i++){
        const xi=path[i].lng(),yi=path[i].lat(),xj=path[j].lng(),yj=path[j].lat();
        const intersect=((yi>y)!==(yj>y))&&(x<(xj-xi)*(y-yi)/((yj-yi)||1e-10)+xi);
        if(intersect) inside=!inside;
      }
    });
    return inside;
  }

  function filterMarkersByEmdPolygon(){
    if(!currentEmdData||!currentEmdData.features) return [];
    const polygonList = currentEmdData.features.map(f=>createPolygon(f));
    const polygons = polygonList.map(p=>p.getPaths().getArray().map(path=>path.getArray()));
    const boundsList = polygonList.map(p=>p.bounds);
    const mapBounds = map.getBounds();

    return markerDataList.filter(m=>{
      const markerPos=new naver.maps.LatLng(m.lat,m.lng);
      if(!mapBounds.hasLatLng(markerPos)) return false;
      let inside=false;
      for(let i=0;i<polygons.length;i++){
        if(!boundsList[i].hasLatLng(markerPos)) continue;
        if(isPointInsidePolygon(markerPos,polygons[i])){ inside=true; break; }
      }
      return inside;
    });
  }

  function renderRegionAtCenter(center){
    if(activePolygon) activePolygon.setMap(null);
    activePolygon = null;
    for(const feature of dataList){
      const polygon=createPolygon(feature);
      const paths=polygon.getPaths().getArray().map(path=>path.getArray());
      if(isPointInsidePolygon(center,paths)){
        polygon.setMap(map); activePolygon=polygon; break;
      }
    }
    updateMarkersByPolygon();
  }

  function updateMarkersByPolygon(){
    if(!activePolygon){
      if(cluster) cluster.setMap(null);
      return;
    }

    const paths=activePolygon.getPaths().getArray().map(path=>path.getArray());
    const visibleMarkers=markers.filter(m=>isPointInsidePolygon(m.getPosition(),paths));
    if(cluster) cluster.setMap(null);
    cluster = new MarkerClustering({
      map, markers:visibleMarkers, disableClickZoom:false, gridSize:300,
      minClusterSize:1, maxZoom:18, icons:clusterIcons,
      indexGenerator:[10,100,200,500,1000],
      stylingFunction:(c,count)=>{c.getElement().querySelector('div:first-child').innerText=count;}
    });
  }

  /* -------------------------------
     ✅ 지도 중심 변경 시 업데이트 (Debounce)
  --------------------------------*/
  let regionUpdateTimer=null;
  function applyRegionUpdate(emdCode){
    currentEmdData=window["emd_"+emdCode]||null;
    const zoom=map.getZoom();
    if(zoom>14) dataList=currentEmdData?currentEmdData.features:[];
    else if(zoom>11) dataList=sigunguGeoJson.features;
    else dataList=[];
    const filteredMarkers=(zoom>14&&currentEmdData)?filterMarkersByEmdPolygon():markerDataList;
    renderMarkers(filteredMarkers);
    renderRegionAtCenter(map.getCenter());
  }

  function updateRegionByCenter(){
    clearTimeout(regionUpdateTimer);
    regionUpdateTimer = setTimeout(()=>{
      const center=map.getCenter();
      naver.maps.Service.reverseGeocode({
        coords:center,
        orders:[naver.maps.Service.OrderType.ADDR,naver.maps.Service.OrderType.ROAD_ADDR].join(',')
      },(status,response)=>{
        if(status!==naver.maps.Service.Status.OK)return;
        const result=response.v2.results[0]; if(!result)return;
        const emdCode=result.code.id.slice(0,2);
        if(window["emd_"+emdCode]) applyRegionUpdate(emdCode);
        else loadEmdScript(emdCode,()=>applyRegionUpdate(emdCode));
      });
    },300); // 300ms 지연 → 불필요한 연속 호출 방지
  }

  /* -------------------------------
     ✅ 기타 UI/기능
  --------------------------------*/
  let myLocationMarker=null;
  function goMyLocation(){
    if(!navigator.geolocation)return;
    navigator.geolocation.getCurrentPosition(pos=>{
      const lat=pos.coords.latitude, lng=pos.coords.longitude;
      const loc=new naver.maps.LatLng(lat,lng);
      if(!myLocationMarker){
        myLocationMarker=new naver.maps.Marker({
          position:loc,map:map,
          icon:{url:"https://maps.gstatic.com/mapfiles/ms2/micons/red-dot.png",
            size:new naver.maps.Size(32,32),scaledSize:new naver.maps.Size(32,32)}
        });
      } else myLocationMarker.setPosition(loc);
      map.setCenter(loc); map.setZoom(16);
      updateAddress(lat,lng);
    },()=>{addressBox.innerText="위치 정보를 가져올 수 없습니다.";});
  }

  function zoomIn(){ map.setZoom(map.getZoom()+1); }
  function zoomOut(){ map.setZoom(map.getZoom()-1); }

  function handleFilterChange(type){
    const filterBtn=document.querySelectorAll(".filterBox button");
    filterBtn.forEach((el,idx)=>el.classList.toggle("active",type===idx));
    markerDataList=(type===0)?markerData:markerData.filter(v=>v.type===type);
    updateRegionByCenter();
  }

  naver.maps.Event.addListener(map,'idle',updateRegionByCenter);
  naver.maps.Event.addListener(map,'zoom_changed',()=>{updateClusterIconsByZoom();updateRegionByCenter();});
  window.addEventListener("load",()=>{goMyLocation();updateRegionByCenter();});

  naver.maps.Event.addListener(map,"click",()=>{
    document.getElementById("mapComponent").classList.toggle("hide");
  });

  function getBaseIcon(size){
    return {
      content:`<div style="cursor:pointer;width:${size}px;height:${size}px;line-height:${size+2}px;font-size:${Math.max(12,size/3)}px;color:white;text-align:center;font-weight:bold;background:url(./image/baseIcon.png);background-size:contain;"></div>`,
      size:new naver.maps.Size(size,size),
      anchor:new naver.maps.Point(size/2,size/2)
    };
  }
  function updateClusterIconsByZoom(){
    const zoom=map.getZoom(),defaultZoom=16-zoom;
    let iconSize=(defaultZoom>0)?50+(10*defaultZoom):50;
    clusterIcons=[1,2,3,4,5].map(()=>getBaseIcon(iconSize));
    if(cluster) updateMarkersByPolygon();
  }
  let clusterIcons=[1,2,3,4,5].map(()=>getBaseIcon(40));
</script>
</body>
</html>
