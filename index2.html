<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>지도 테스트</title>
  <!-- ✅ defer 추가 -->
  <script src="https://oapi.map.naver.com/openapi/v3/maps.js?ncpKeyId=n08un8adzv&submodules=geocoder" defer></script>
  <script src="./MarkerClustering.js" defer></script>
  <script src="./markerData.js" defer></script>
  <script src="./sigunguData.js" defer></script>
  <style>
    body { margin: 0; padding: 0; }
    #map { width:100dvw; height:100dvh; min-width: 280px; min-height: 400px; }
    /* ✅ Skeleton UI */
    #mapPlaceholder {
      width: 100dvw;
      height: 100dvh;
      min-width: 280px;
      min-height: 400px;
      background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
      background-size: 200% 100%;
      animation: shimmer 1.5s infinite;
    }
    @keyframes shimmer {
      0% { background-position: -200% 0; }
      100% { background-position: 200% 0; }
    }
  </style>
</head>
<body>
<!-- ✅ 로딩 중에는 Skeleton UI 먼저 표시 -->
<div id="mapPlaceholder"></div>
<div id="map" style="display:none;"></div>

<script>
  document.addEventListener("DOMContentLoaded", () => {
    /* -------------------------------
       ✅ 전역 변수
    --------------------------------*/
    const map = new naver.maps.Map('map', {
      center: new naver.maps.LatLng(35.144, 129.060),
      zoom: 16, minZoom:7, maxZoom:19
    });

    const loadedEmdCodes = [];
    const polygonCache = {};
    let activePolygon = null;
    let currentEmdData = null;
    let dataList = [];

    /* -------------------------------
       ✅ 동적 행정동 데이터 로드
    --------------------------------*/
    function loadEmdScript(code, callback) {
      if (window["emd_" + code]) {
        if (!loadedEmdCodes.includes(code)) loadedEmdCodes.push(code);
        callback && callback();
        return;
      }
      if (loadedEmdCodes.includes(code)) {
        callback && callback();
        return;
      }
      const script = document.createElement("script");
      script.src = `./dongData/emd_${code}.js`;
      script.onload = () => {
        loadedEmdCodes.push(code);
        callback && callback();
      };
      document.body.appendChild(script);
    }

    function createPolygon(feature) {
      const key = feature.properties.EMD_CD || JSON.stringify(feature.geometry);
      if (polygonCache[key]) return polygonCache[key];

      const paths = [];
      if (feature.geometry.type === "Polygon") {
        feature.geometry.coordinates.forEach(ring =>
          paths.push(ring.map(([lng, lat]) => new naver.maps.LatLng(lat, lng)))
        );
      } else {
        feature.geometry.coordinates.forEach(poly =>
          poly.forEach(ring =>
            paths.push(ring.map(([lng, lat]) => new naver.maps.LatLng(lat, lng)))
          )
        );
      }

      const polygon = new naver.maps.Polygon({
        paths,
        fillColor: '#FE7E33',
        fillOpacity: 0.1,
        strokeColor: '#FE7E33',
        strokeOpacity: 1,
        strokeWeight: 2,
        clickable: false
      });

      polygonCache[key] = polygon;
      return polygon;
    }

    function isPointInsidePolygon(point, paths) {
      const x = point.lng(), y = point.lat();
      let inside = false;
      paths.forEach(path => {
        for (let i = 0, j = path.length - 1; i < path.length; j = i++) {
          const xi = path[i].lng(), yi = path[i].lat();
          const xj = path[j].lng(), yj = path[j].lat();
          const intersect = ((yi > y) !== (yj > y)) &&
            (x < (xj - xi) * (y - yi) / ((yj - yi) || 1e-10) + xi);
          if (intersect) inside = !inside;
        }
      });
      return inside;
    }

    function renderRegionAtCenter(center) {
      if (activePolygon) activePolygon.setMap(null);
      activePolygon = null;

      for (const feature of dataList) {
        const polygon = createPolygon(feature);
        const paths = polygon.getPaths().getArray().map(path => path.getArray());
        if (isPointInsidePolygon(center, paths)) {
          polygon.setMap(map);
          activePolygon = polygon;
          break;
        }
      }
    }

    function applyRegionUpdate(emdCode) {
      currentEmdData = window["emd_" + emdCode] || null;
      const zoom = map.getZoom();
      if (zoom > 14) {
        dataList = currentEmdData ? currentEmdData.features : [];
      } else if (zoom > 11) {
        dataList = sigunguGeoJson.features;
      } else {
        dataList = [];
      }
      renderRegionAtCenter(map.getCenter());
    }

    let regionUpdateTimer = null;
    function updateRegionByCenter() {
      clearTimeout(regionUpdateTimer);
      regionUpdateTimer = setTimeout(() => {
        const center = map.getCenter();
        naver.maps.Service.reverseGeocode({
          coords: center,
          orders: [naver.maps.Service.OrderType.ADDR, naver.maps.Service.OrderType.ROAD_ADDR].join(',')
        }, (status, response) => {
          if (status !== naver.maps.Service.Status.OK) return;
          const result = response.v2.results[0];
          if (!result) return;
          const emdCode = result.code.id.slice(0, 2);
          if (window["emd_" + emdCode]) {
            applyRegionUpdate(emdCode);
          } else {
            loadEmdScript(emdCode, () => applyRegionUpdate(emdCode));
          }
        });
      }, 300);
    }

    naver.maps.Event.addListener(map, 'idle', updateRegionByCenter);

    // ✅ tilesloaded 이벤트로 지도 완전히 로드 후 Skeleton 제거
    naver.maps.Event.addListener(map, 'tilesloaded', () => {
      document.getElementById("mapPlaceholder").style.display = "none";
      document.getElementById("map").style.display = "block";
    });

    // 초기 실행
    updateRegionByCenter();
  });
</script>
</body>
</html>
